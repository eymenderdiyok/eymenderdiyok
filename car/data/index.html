<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Car Driver 3D | Ultimate</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* MODERN UI KATMANI */
        .overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); z-index: 100; color: white; transition: opacity 0.5s; }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        
        .card { background: rgba(255,255,255,0.08); padding: 40px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.1); text-align: center; width: 90%; max-width: 400px; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        
        h1 { margin: 0 0 20px 0; font-size: 2.5rem; letter-spacing: 2px; text-transform: uppercase; background: linear-gradient(to right, #fff, #aaa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .btn { background: #0071e3; color: white; border: none; padding: 18px 40px; border-radius: 15px; font-size: 1.2rem; font-weight: bold; cursor: pointer; width: 100%; transition: 0.2s; margin-top: 20px; }
        .btn:hover { background: #0077ed; transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,113,227,0.3); }
        
        /* HUD */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box; }
        .hud-top { display: flex; justify-content: space-between; font-size: 1.5rem; font-weight: 800; color: white; text-shadow: 2px 2px 0 rgba(0,0,0,0.5); }
        .speedometer { align-self: flex-end; text-align: right; }
        .speed-val { font-size: 4.5rem; font-weight: 900; color: white; display: block; line-height: 0.9; text-shadow: 3px 3px 0 rgba(0,0,0,0.5); font-variant-numeric: tabular-nums; }
        .speed-label { font-size: 1rem; color: #ccc; letter-spacing: 2px; }

        /* Mobile Controls */
        .controls { position: absolute; bottom: 20px; width: 100%; height: 150px; display: none; pointer-events: all; }
        @media (hover: none) and (pointer: coarse) { .controls { display: flex; } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="start-screen" class="overlay">
        <div class="card">
            <h1>Neon Racer</h1>
            <p style="color: #aaa; margin-bottom: 30px;">Ger√ßek√ßi S√ºr√º≈ü Deneyimi</p>
            <button class="btn" onclick="startGame()">YARI≈ûA BA≈ûLA</button>
        </div>
    </div>

    <div id="hud" class="hidden">
        <div class="hud-top">
            <div id="pos-display">POS 1/8</div>
            <div id="lap-display">LAP 1/3</div>
        </div>
        <div class="speedometer">
            <span id="speed-display" class="speed-val">0</span>
            <span class="speed-label">KM/H</span>
        </div>
    </div>

    <div id="end-screen" class="overlay hidden">
        <div class="card">
            <div id="medal" style="font-size: 5rem; margin-bottom: 10px;">üèÜ</div>
            <h2 id="end-title">YARI≈û Bƒ∞TTƒ∞</h2>
            <button class="btn" onclick="location.reload()">TEKRAR OYNA</button>
        </div>
    </div>

<script>
/**
 * ULTRA OPTIMIZED 3D ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Performans i√ßin alpha kapalƒ±

// AYARLAR
const CFG = {
    roadWidth: 2000,
    segmentLength: 200,
    cameraHeight: 1000,
    cameraDepth: 0.84,
    drawDistance: 300, // Ufuk √ßizgisi mesafesi
    fov: 100,
    maxSpeed: 26000,
    accel: 6000,
    breaking: -10000,
    decel: -3000,
    offRoadDecel: -10000,
    turnSpeed: 1.8 // Viraj hassasiyeti
};

let player = { x: 0, z: 0, speed: 0, lap: 0 };
let segments = [];
let cars = [];
let running = false;
let keys = {};
let lastTime = 0;
let trackLength = 0;

// KONTROLLER
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    
    // Canvas Boyutlandƒ±rma
    resize();
    window.addEventListener('resize', resize);

    createRoad();
    createCars();
    
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

// YOL OLU≈ûTURMA
function createRoad() {
    segments = [];
    const createSection = (count, curve, y) => {
        for(let i=0; i<count; i++) {
            const idx = segments.length;
            segments.push({
                index: idx,
                p1: { world: { z: idx * CFG.segmentLength }, screen: {} },
                p2: { world: { z: (idx+1) * CFG.segmentLength }, screen: {} },
                curve: curve,
                color: Math.floor(idx/3)%2 ? {r:50,g:50,b:50} : {r:45,g:45,b:45}, // Koyu Asfalt
                tree: (idx % 8 === 0) ? (Math.random() > 0.5 ? 1 : -1) : 0
            });
        }
    };

    // Pist Tasarƒ±mƒ±
    createSection(100, 0, 0);       // D√ºz
    createSection(200, 2, 0);       // Saƒü Viraj
    createSection(100, 0, 0);       // D√ºz
    createSection(200, -2, 0);      // Sol Viraj
    createSection(100, 0, 0);       // D√ºz
    createSection(300, -3, 0);      // Sert Sol
    createSection(200, 3, 0);       // Sert Saƒü
    createSection(300, 0, 0);       // Biti≈ü D√ºzl√ºƒü√º

    trackLength = segments.length * CFG.segmentLength;
}

function createCars() {
    cars = [];
    for(let i=0; i<8; i++) {
        cars.push({
            offset: Math.random() * 0.8 * (Math.random() > 0.5 ? 1 : -1),
            z: (i+1) * 3000,
            speed: 15000 + Math.random() * 8000,
            color: `hsl(${Math.random()*360}, 70%, 50%)`,
            mesh: Math.floor(Math.random() * 3) // 3 farklƒ± araba tipi (render i√ßin)
        });
    }
}

// OYUN D√ñNG√úS√ú
function loop(time) {
    if(!running) return;
    const dt = Math.min(1, (time - lastTime) / 1000);
    lastTime = time;

    update(dt);
    render();
    requestAnimationFrame(loop);
}

function update(dt) {
    // 1. Fizik ve Kontroller
    const speedRatio = player.speed / CFG.maxSpeed;
    const dx = dt * CFG.turnSpeed * speedRatio;

    // Hƒ±zlanma / Fren (D√∂n√º≈üte yava≈ülama KALDIRILDI)
    if (keys['ArrowUp'] || keys['KeyW']) player.speed += CFG.accel * dt;
    else if (keys['ArrowDown'] || keys['KeyS']) player.speed += CFG.breaking * dt;
    else player.speed += CFG.decel * dt;

    // Direksiyon
    if (keys['ArrowLeft'] || keys['KeyA']) player.x = player.x - dx;
    if (keys['ArrowRight'] || keys['KeyD']) player.x = player.x + dx;

    // Merkezka√ß Kuvveti (Virajda dƒ±≈üarƒ± savrulma)
    const playerSegment = segments[Math.floor(player.z / CFG.segmentLength) % segments.length];
    player.x = player.x - (dx * speedRatio * playerSegment.curve * 2); // Virajƒ±n tersine iter

    // √áimlere √ßƒ±kƒ±nca yava≈üla
    if ((player.x < -1 || player.x > 1) && player.speed > 8000) {
        player.speed += CFG.offRoadDecel * dt;
    }

    // Sƒ±nƒ±rlandƒ±rma
    player.x = Math.max(-2, Math.min(2, player.x));
    player.speed = Math.max(0, Math.min(CFG.maxSpeed, player.speed));

    // Hareket
    player.z += player.speed * dt;
    if (player.z >= trackLength) {
        player.z -= trackLength;
        player.lap++;
        if(player.lap > 3) endGame();
    }

    // Rakipleri Hareket Ettir
    cars.forEach(car => {
        car.z += car.speed * dt;
        if(car.z >= trackLength) car.z -= trackLength;
    });

    // UI G√ºncelle
    document.getElementById('speed-display').innerText = Math.floor(player.speed / 100);
    let rank = 1;
    cars.forEach(c => { if(c.z > player.z) rank++; });
    document.getElementById('pos-display').innerText = `POS ${rank}/9`;
}

// RENDER MOTORU
function render() {
    // 1. Temizle ve Arkaplan
    ctx.fillStyle = "#4ec0ff"; // G√∂ky√ºz√º
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#2c8f1b"; // Zemin (√áim)
    ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);

    // 2. Yol Projeksiyonu
    let baseSegment = segments[Math.floor(player.z / CFG.segmentLength) % segments.length];
    let basePercent = (player.z % CFG.segmentLength) / CFG.segmentLength;
    let dx = -(baseSegment.curve * basePercent);
    let x = 0;
    let maxY = canvas.height; // Ufuk √ßizgisi kƒ±rpma (Clipping)

    const project = (p, cX, cY, cZ, camX) => {
        p.camera.x = (p.world.z || 0) - camX; // Basit hack
        p.screen.scale = CFG.cameraDepth / (p.world.z - player.z + (p.world.z < player.z ? trackLength : 0));
        
        // Ger√ßek 3D Projeksiyon Form√ºl√º
        let scale = p.screen.scale;
        p.screen.x = Math.round((canvas.width/2) + (scale * ((p.world.x || 0) - player.x - x) * canvas.width/2));
        p.screen.y = Math.round((canvas.height/2) - (scale * CFG.cameraHeight * canvas.height/2));
        p.screen.w = Math.round(scale * CFG.roadWidth * canvas.width/2);
    };

    // Yol √áizimi (Arkadan √ñne Deƒüil, √ñnden Arkaya √áizilmez -> Painter's Algo i√ßin Arkadan √ñne)
    // Ancak performans i√ßin: Z-Buffer yok, o y√ºzden d√∂ng√ºy√º renderDistance kadar yapƒ±yoruz.
    
    // Doƒüru Y√∂ntem: Ufuk √ßizgisinden (en uzaktan) oyuncuya doƒüru √ßizmek deƒüil,
    // Oyuncudan uzaƒüa doƒüru √ßizip, 'maxY' kullanarak √ºst √ºste binmeyi engellemek daha iyidir (Outrun Style).
    
    // YENƒ∞ RENDER LOOP (Yol ƒ∞√ßin)
    let renderList = [];
    x = 0;
    dx = 0;
    
    // Kamera pozisyonu
    let camH = CFG.cameraHeight + segments[Math.floor(player.z/CFG.segmentLength)%segments.length].y * 0; // Y√ºkseklik yok ≈üimdilik

    // Sadece g√∂r√º≈ü mesafesindekileri i≈üle
    for(let n=0; n<CFG.drawDistance; n++) {
        let segment = segments[(baseSegment.index + n) % segments.length];
        let looped = segment.index < baseSegment.index;
        
        // D√ºnya Koordinatlarƒ±
        let p1 = segment.p1;
        let p2 = segment.p2;
        
        // Oyuncuya g√∂re Z pozisyonu
        let cameraZ = (looped ? trackLength : 0) + (n * CFG.segmentLength) - (player.z % CFG.segmentLength);
        
        // Ekrana ƒ∞zd√º≈ü√ºm (Project)
        let scale = CFG.cameraDepth / cameraZ;
        let screenX = (canvas.width/2) + (scale * (-player.x * CFG.roadWidth - x) * canvas.width/2);
        let screenY = (canvas.height/2) - (scale * (CFG.cameraHeight) * canvas.height/2);
        let screenW = scale * CFG.roadWidth * canvas.width/2;

        // Bir sonraki segment i√ßin X kaymasƒ± (Viraj)
        x += dx;
        dx += segment.curve;

        // Segment √∂zelliklerini sakla (daha sonra √ßizmek i√ßin deƒüil, ≈üu an √ßizmek daha iyi)
        // Clipping: Eƒüer segment ekranƒ±n altƒ±ndaysa veya ufuk √ßizgisinin √ºst√ºnde kalƒ±yorsa √ßizme
        if (screenY >= maxY) continue;
        
        // √áƒ∞Zƒ∞M
        let prevY = (canvas.height/2) - ((CFG.cameraDepth / (cameraZ - CFG.segmentLength)) * CFG.cameraHeight * canvas.height/2); // Basit yakla≈üƒ±m
        
        // Bu segmenti √ßiz
        // Renkler
        let color = segment.color;
        let grass = (Math.floor(segment.index/3)%2) ? "#2c8f1b" : "#35a522";
        
        // Zemin (Segment y√ºksekliƒüi ile bir √∂nceki arasƒ±na doldur)
        // Basitle≈ütirilmi≈ü: Sadece yol √ßiz.
        
        // P1 ve P2 screen koordinatlarƒ± hesaplama (Daha hassas)
        let p1_scale = CFG.cameraDepth / cameraZ;
        let p1_y = (canvas.height/2) - (p1_scale * CFG.cameraHeight * canvas.height/2);
        let p1_w = p1_scale * CFG.roadWidth * canvas.width/2;
        let p1_x = (canvas.width/2) + (p1_scale * (-player.x * CFG.roadWidth - (x - dx)) * canvas.width/2); // √ñnceki x

        // P2 (Bu segmentin sonu) - Zaten hesapladƒ±k screenX, screenY
        // D√ºzeltme: D√∂ng√º k√ºm√ºlatif gidiyor.
        
        // BASƒ∞T RENDER TEKNƒ∞ƒûƒ∞ (Outrun Style)
        // Her segmenti √ßiz ve maxY'yi g√ºncelle.
        
        ctx.fillStyle = (Math.floor(segment.index/2)%2) ? "#555" : "#505050"; // Asfalt
        ctx.beginPath();
        ctx.moveTo(p1_x - p1_w, p1_y);
        ctx.lineTo(p1_x + p1_w, p1_y);
        ctx.lineTo(screenX + screenW, screenY);
        ctx.lineTo(screenX - screenW, screenY);
        ctx.fill();
        
        // ≈ûeritler
        if(Math.floor(segment.index/2)%2) {
            ctx.fillStyle = "white";
            let lw = screenW * 0.05;
            ctx.fillRect(screenX - lw/2, screenY, lw, p1_y - screenY);
        }
        
        // Kenarlƒ±klar
        ctx.fillStyle = (Math.floor(segment.index/2)%2) ? "red" : "white";
        ctx.fillRect(screenX - screenW * 1.2, screenY, screenW * 0.2, p1_y - screenY);
        ctx.fillRect(screenX + screenW, screenY, screenW * 0.2, p1_y - screenY);

        // Aƒüa√ßlar ve Arabalarƒ± kaydet
        segment.clipY = p1_y; // Bu segmentin ekran Y'si
        segment.screenX = screenX; 
        segment.scale = scale;

        maxY = screenY; // Yeni kƒ±rpma noktasƒ± (yukarƒ± doƒüru gidiyoruz)
    }

    // 3. SPRITE RENDER (Arkadan √ñne)
    // T√ºm arabalarƒ± ve aƒüa√ßlarƒ± topla, Z'ye g√∂re sƒ±rala ve √ßiz.
    
    let sprites = [];
    
    // Rakipler
    cars.forEach(car => {
        // Arabanƒ±n Z mesafesi (Player'a g√∂re)
        let dist = car.z - player.z;
        if(dist < 0) dist += trackLength;
        
        // √áOK √ñNEMLƒ∞: Sadece DrawDistance i√ßindeyse ekle!
        if(dist > CFG.drawDistance * CFG.segmentLength) return;

        // Hangi segmentte?
        // Arabanƒ±n X konumunu yol kƒ±vrƒ±mƒ±na g√∂re hesapla
        // Bu kƒ±sƒ±m karma≈üƒ±k, basitle≈ütirilmi≈ü bir X ofseti kullanacaƒüƒ±z.
        // Arabanƒ±n olduƒüu segmentin renderdaki X kaymasƒ±nƒ± bulmamƒ±z lazƒ±m.
        // Ama basit√ße:
        
        let spriteScale = CFG.cameraDepth / dist;
        // Arabanƒ±n yatay konumu: Yolun o anki kƒ±vrƒ±mƒ± (offset) + arabanƒ±n kendi ≈üeridi
        // Bunu tam senkronize etmek i√ßin render loop i√ßinde toplamak en iyisidir ama bu da √ßalƒ±≈üƒ±r.
        
        // X d√ºzeltmesi:
        // Render loop'taki k√ºm√ºlatif X'i tahmin edemeyiz.
        // O y√ºzden en iyi y√∂ntem: Arabanƒ±n olduƒüu segmenti bul.
        let carSegIdx = Math.floor(car.z / CFG.segmentLength) % segments.length;
        let carSeg = segments[carSegIdx];
        
        // Eƒüer segment render edilmediyse (g√∂r√ºnm√ºyorsa) √ßizme
        if (!carSeg.scale) return; 

        let carX = carSeg.screenX + (carSeg.scale * car.offset * CFG.roadWidth * canvas.width/2);
        let carY = carSeg.clipY;

        sprites.push({ type: 'car', z: dist, x: carX, y: carY, s: spriteScale, c: car });
    });

    // Aƒüa√ßlar (Sadece g√∂r√ºn√ºr segmenttekiler)
    for(let n=CFG.drawDistance; n>0; n--) {
        let idx = (baseSegment.index + n) % segments.length;
        let seg = segments[idx];
        if(seg.tree && seg.scale) {
             let dist = n * CFG.segmentLength; // Yakla≈üƒ±k
             let treeX = seg.screenX + (seg.scale * seg.tree * CFG.roadWidth * canvas.width/2 * 1.5);
             sprites.push({ type: 'tree', z: dist, x: treeX, y: seg.clipY, s: seg.scale });
        }
    }

    // Sƒ±rala: En uzaktakini √∂nce √ßiz (Painters Algo)
    sprites.sort((a,b) => b.z - a.z);

    // √áiz
    sprites.forEach(sp => {
        if(sp.type === 'car') drawCarBody(sp.x, sp.y, sp.s * 8000, sp.c);
        if(sp.type === 'tree') drawTree(sp.x, sp.y, sp.s * 6000);
    });

    // 4. Player Car (En √ºstte)
    drawCarBody(canvas.width/2, canvas.height - 100, 450, {color: '#d63031', mesh: 0}, true);
}

// YARDIMCI √áƒ∞Zƒ∞M FONKSƒ∞YONLARI
function drawCarBody(x, y, w, carObj, isPlayer=false) {
    let h = w * 0.5;
    let yPos = y - h; // Tekerlek hizasƒ±
    
    // G√∂lge
    ctx.fillStyle = "rgba(0,0,0,0.4)";
    ctx.beginPath(); ctx.ellipse(x, yPos + h*0.8, w*0.6, h*0.15, 0, 0, Math.PI*2); ctx.fill();
    
    // Alt G√∂vde
    ctx.fillStyle = carObj.color;
    // Yuvarlak hatlar
    ctx.beginPath();
    ctx.roundRect(x - w/2, yPos, w, h*0.6, w*0.1);
    ctx.fill();
    
    // √úst Kabin (Cam)
    ctx.fillStyle = "#111"; // Cam rengi
    let roofW = w * 0.6;
    ctx.beginPath();
    ctx.moveTo(x - roofW/2, yPos);
    ctx.lineTo(x - roofW/2 + w*0.1, yPos - h*0.5); // Sol direk
    ctx.lineTo(x + roofW/2 - w*0.1, yPos - h*0.5); // Saƒü direk
    ctx.lineTo(x + roofW/2, yPos);
    ctx.fill();
    
    // Stop Lambalarƒ±
    let lightColor = (isPlayer && (keys['ArrowDown']||keys['KeyS'])) ? "#ff0000" : "#8b0000";
    ctx.fillStyle = lightColor;
    ctx.fillRect(x - w*0.4, yPos + h*0.1, w*0.15, h*0.15);
    ctx.fillRect(x + w*0.25, yPos + h*0.1, w*0.15, h*0.15);
    
    // Plaka
    if(w > 50) {
        ctx.fillStyle = "white";
        ctx.fillRect(x - w*0.1, yPos + h*0.3, w*0.2, h*0.1);
    }
}

function drawTree(x, y, s) {
    // Basit Vekt√∂rel Aƒüa√ß
    let w = s * 0.5; 
    let h = s * 1.2;
    // G√∂vde
    ctx.fillStyle = "#5d4037";
    ctx.fillRect(x - w/4, y - h, w/2, h);
    // Yapraklar (3 katmanlƒ±)
    ctx.fillStyle = "#2e7d32";
    ctx.beginPath(); ctx.moveTo(x - w, y - h*0.3); ctx.lineTo(x, y - h*1.5); ctx.lineTo(x + w, y - h*0.3); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x - w*0.8, y - h*0.8); ctx.lineTo(x, y - h*1.8); ctx.lineTo(x + w*0.8, y - h*0.8); ctx.fill();
}

function endGame() {
    running = false;
    document.getElementById('end-screen').classList.remove('hidden');
    let rank = 1;
    cars.forEach(c => { if(c.z > player.z) rank++; });
    document.getElementById('end-title').innerText = rank + ". OLDUNUZ!";
}
</script>
</body>
</html>
